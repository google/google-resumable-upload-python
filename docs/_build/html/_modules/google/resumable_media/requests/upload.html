

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>google.resumable_media.requests.upload &#8212; google-resumable-media  documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
          	<div class="admonition" id="python2-eol"> 
          	 As of January 1, 2020 this library no longer supports Python 2 on the latest released version. 
          	 Library versions released prior to that date will continue to be available. For more information please
          	 visit <a href="https://cloud.google.com/python/docs/python2-sunset/">Python 2 support on Google Cloud</a>.
          	</div>
            
  <h1>Source code for google.resumable_media.requests.upload</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2017 Google Inc.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;Support for resumable uploads.</span>

<span class="sd">Also supported here are simple (media) uploads and multipart</span>
<span class="sd">uploads that contain both metadata and a small file as payload.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">google.resumable_media</span> <span class="kn">import</span> <span class="n">_upload</span>
<span class="kn">from</span> <span class="nn">google.resumable_media.requests</span> <span class="kn">import</span> <span class="n">_request_helpers</span>


<div class="viewcode-block" id="SimpleUpload"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.SimpleUpload">[docs]</a><span class="k">class</span> <span class="nc">SimpleUpload</span><span class="p">(</span><span class="n">_request_helpers</span><span class="o">.</span><span class="n">RequestsMixin</span><span class="p">,</span> <span class="n">_upload</span><span class="o">.</span><span class="n">SimpleUpload</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upload a resource to a Google API.</span>

<span class="sd">    A **simple** media upload sends no metadata and completes the upload</span>
<span class="sd">    in a single request.</span>

<span class="sd">    Args:</span>
<span class="sd">        upload_url (str): The URL where the content will be uploaded.</span>
<span class="sd">        headers (Optional[Mapping[str, str]]): Extra headers that should</span>
<span class="sd">            be sent with the request, e.g. headers for encrypted data.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        upload_url (str): The URL where the content will be uploaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SimpleUpload.transmit"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.SimpleUpload.transmit">[docs]</a>    <span class="k">def</span> <span class="nf">transmit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transport</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">content_type</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="p">(</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_CONNECT_TIMEOUT</span><span class="p">,</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_READ_TIMEOUT</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transmit the resource to be uploaded.</span>

<span class="sd">        Args:</span>
<span class="sd">            transport (~requests.Session): A ``requests`` object which can</span>
<span class="sd">                make authenticated requests.</span>
<span class="sd">            data (bytes): The resource content to be uploaded.</span>
<span class="sd">            content_type (str): The content type of the resource, e.g. a JPEG</span>
<span class="sd">                image has content type ``image/jpeg``.</span>
<span class="sd">            timeout (Optional[Union[float, Tuple[float, float]]]):</span>
<span class="sd">                The number of seconds to wait for the server response.</span>
<span class="sd">                Depending on the retry strategy, a request may be repeated</span>
<span class="sd">                several times using the same timeout each time.</span>

<span class="sd">                Can also be passed as a tuple (connect_timeout, read_timeout).</span>
<span class="sd">                See :meth:`requests.Session.request` documentation for details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ~requests.Response: The HTTP response returned by ``transport``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_request</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">content_type</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">_request_helpers</span><span class="o">.</span><span class="n">http_request</span><span class="p">(</span>
            <span class="n">transport</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
            <span class="n">retry_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_strategy</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_response</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span></div></div>


<div class="viewcode-block" id="MultipartUpload"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.MultipartUpload">[docs]</a><span class="k">class</span> <span class="nc">MultipartUpload</span><span class="p">(</span><span class="n">_request_helpers</span><span class="o">.</span><span class="n">RequestsMixin</span><span class="p">,</span> <span class="n">_upload</span><span class="o">.</span><span class="n">MultipartUpload</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upload a resource with metadata to a Google API.</span>

<span class="sd">    A **multipart** upload sends both metadata and the resource in a single</span>
<span class="sd">    (multipart) request.</span>

<span class="sd">    Args:</span>
<span class="sd">        upload_url (str): The URL where the content will be uploaded.</span>
<span class="sd">        headers (Optional[Mapping[str, str]]): Extra headers that should</span>
<span class="sd">            be sent with the request, e.g. headers for encrypted data.</span>
<span class="sd">        checksum Optional([str]): The type of checksum to compute to verify</span>
<span class="sd">            the integrity of the object. The request metadata will be amended</span>
<span class="sd">            to include the computed value. Using this option will override a</span>
<span class="sd">            manually-set checksum value. Supported values are &quot;md5&quot;,</span>
<span class="sd">            &quot;crc32c&quot; and None. The default is None.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        upload_url (str): The URL where the content will be uploaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MultipartUpload.transmit"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.MultipartUpload.transmit">[docs]</a>    <span class="k">def</span> <span class="nf">transmit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transport</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">,</span>
        <span class="n">content_type</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="p">(</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_CONNECT_TIMEOUT</span><span class="p">,</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_READ_TIMEOUT</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transmit the resource to be uploaded.</span>

<span class="sd">        Args:</span>
<span class="sd">            transport (~requests.Session): A ``requests`` object which can</span>
<span class="sd">                make authenticated requests.</span>
<span class="sd">            data (bytes): The resource content to be uploaded.</span>
<span class="sd">            metadata (Mapping[str, str]): The resource metadata, such as an</span>
<span class="sd">                ACL list.</span>
<span class="sd">            content_type (str): The content type of the resource, e.g. a JPEG</span>
<span class="sd">                image has content type ``image/jpeg``.</span>
<span class="sd">            timeout (Optional[Union[float, Tuple[float, float]]]):</span>
<span class="sd">                The number of seconds to wait for the server response.</span>
<span class="sd">                Depending on the retry strategy, a request may be repeated</span>
<span class="sd">                several times using the same timeout each time.</span>

<span class="sd">                Can also be passed as a tuple (connect_timeout, read_timeout).</span>
<span class="sd">                See :meth:`requests.Session.request` documentation for details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ~requests.Response: The HTTP response returned by ``transport``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_request</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">content_type</span>
        <span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">_request_helpers</span><span class="o">.</span><span class="n">http_request</span><span class="p">(</span>
            <span class="n">transport</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
            <span class="n">retry_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_strategy</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_response</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span></div></div>


<div class="viewcode-block" id="ResumableUpload"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.ResumableUpload">[docs]</a><span class="k">class</span> <span class="nc">ResumableUpload</span><span class="p">(</span><span class="n">_request_helpers</span><span class="o">.</span><span class="n">RequestsMixin</span><span class="p">,</span> <span class="n">_upload</span><span class="o">.</span><span class="n">ResumableUpload</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initiate and fulfill a resumable upload to a Google API.</span>

<span class="sd">    A **resumable** upload sends an initial request with the resource metadata</span>
<span class="sd">    and then gets assigned an upload ID / upload URL to send bytes to.</span>
<span class="sd">    Using the upload URL, the upload is then done in chunks (determined by</span>
<span class="sd">    the user) until all bytes have been uploaded.</span>

<span class="sd">    When constructing a resumable upload, only the resumable upload URL and</span>
<span class="sd">    the chunk size are required:</span>

<span class="sd">    .. testsetup:: resumable-constructor</span>

<span class="sd">       bucket = u&#39;bucket-foo&#39;</span>

<span class="sd">    .. doctest:: resumable-constructor</span>

<span class="sd">       &gt;&gt;&gt; from google.resumable_media.requests import ResumableUpload</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; url_template = (</span>
<span class="sd">       ...     u&#39;https://www.googleapis.com/upload/storage/v1/b/{bucket}/o?&#39;</span>
<span class="sd">       ...     u&#39;uploadType=resumable&#39;)</span>
<span class="sd">       &gt;&gt;&gt; upload_url = url_template.format(bucket=bucket)</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; chunk_size = 3 * 1024 * 1024  # 3MB</span>
<span class="sd">       &gt;&gt;&gt; upload = ResumableUpload(upload_url, chunk_size)</span>

<span class="sd">    When initiating an upload (via :meth:`initiate`), the caller is expected</span>
<span class="sd">    to pass the resource being uploaded as a file-like ``stream``. If the size</span>
<span class="sd">    of the resource is explicitly known, it can be passed in directly:</span>

<span class="sd">    .. testsetup:: resumable-explicit-size</span>

<span class="sd">       import os</span>
<span class="sd">       import tempfile</span>

<span class="sd">       import mock</span>
<span class="sd">       import requests</span>
<span class="sd">       from six.moves import http_client</span>

<span class="sd">       from google.resumable_media.requests import ResumableUpload</span>

<span class="sd">       upload_url = u&#39;http://test.invalid&#39;</span>
<span class="sd">       chunk_size = 3 * 1024 * 1024  # 3MB</span>
<span class="sd">       upload = ResumableUpload(upload_url, chunk_size)</span>

<span class="sd">       file_desc, filename = tempfile.mkstemp()</span>
<span class="sd">       os.close(file_desc)</span>

<span class="sd">       data = b&#39;some bytes!&#39;</span>
<span class="sd">       with open(filename, u&#39;wb&#39;) as file_obj:</span>
<span class="sd">           file_obj.write(data)</span>

<span class="sd">       fake_response = requests.Response()</span>
<span class="sd">       fake_response.status_code = int(http_client.OK)</span>
<span class="sd">       fake_response._content = b&#39;&#39;</span>
<span class="sd">       resumable_url = u&#39;http://test.invalid?upload_id=7up&#39;</span>
<span class="sd">       fake_response.headers[u&#39;location&#39;] = resumable_url</span>

<span class="sd">       post_method = mock.Mock(return_value=fake_response, spec=[])</span>
<span class="sd">       transport = mock.Mock(request=post_method, spec=[&#39;request&#39;])</span>

<span class="sd">    .. doctest:: resumable-explicit-size</span>

<span class="sd">       &gt;&gt;&gt; import os</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; upload.total_bytes is None</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; stream = open(filename, u&#39;rb&#39;)</span>
<span class="sd">       &gt;&gt;&gt; total_bytes = os.path.getsize(filename)</span>
<span class="sd">       &gt;&gt;&gt; metadata = {u&#39;name&#39;: filename}</span>
<span class="sd">       &gt;&gt;&gt; response = upload.initiate(</span>
<span class="sd">       ...     transport, stream, metadata, u&#39;text/plain&#39;,</span>
<span class="sd">       ...     total_bytes=total_bytes)</span>
<span class="sd">       &gt;&gt;&gt; response</span>
<span class="sd">       &lt;Response [200]&gt;</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; upload.total_bytes == total_bytes</span>
<span class="sd">       True</span>

<span class="sd">    .. testcleanup:: resumable-explicit-size</span>

<span class="sd">       os.remove(filename)</span>

<span class="sd">    If the stream is in a &quot;final&quot; state (i.e. it won&#39;t have any more bytes</span>
<span class="sd">    written to it), the total number of bytes can be determined implicitly</span>
<span class="sd">    from the ``stream`` itself:</span>

<span class="sd">    .. testsetup:: resumable-implicit-size</span>

<span class="sd">       import io</span>

<span class="sd">       import mock</span>
<span class="sd">       import requests</span>
<span class="sd">       from six.moves import http_client</span>

<span class="sd">       from google.resumable_media.requests import ResumableUpload</span>

<span class="sd">       upload_url = u&#39;http://test.invalid&#39;</span>
<span class="sd">       chunk_size = 3 * 1024 * 1024  # 3MB</span>
<span class="sd">       upload = ResumableUpload(upload_url, chunk_size)</span>

<span class="sd">       fake_response = requests.Response()</span>
<span class="sd">       fake_response.status_code = int(http_client.OK)</span>
<span class="sd">       fake_response._content = b&#39;&#39;</span>
<span class="sd">       resumable_url = u&#39;http://test.invalid?upload_id=7up&#39;</span>
<span class="sd">       fake_response.headers[u&#39;location&#39;] = resumable_url</span>

<span class="sd">       post_method = mock.Mock(return_value=fake_response, spec=[])</span>
<span class="sd">       transport = mock.Mock(request=post_method, spec=[&#39;request&#39;])</span>

<span class="sd">       data = b&#39;some MOAR bytes!&#39;</span>
<span class="sd">       metadata = {u&#39;name&#39;: u&#39;some-file.jpg&#39;}</span>
<span class="sd">       content_type = u&#39;image/jpeg&#39;</span>

<span class="sd">    .. doctest:: resumable-implicit-size</span>

<span class="sd">       &gt;&gt;&gt; stream = io.BytesIO(data)</span>
<span class="sd">       &gt;&gt;&gt; response = upload.initiate(</span>
<span class="sd">       ...     transport, stream, metadata, content_type)</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; upload.total_bytes == len(data)</span>
<span class="sd">       True</span>

<span class="sd">    If the size of the resource is **unknown** when the upload is initiated,</span>
<span class="sd">    the ``stream_final`` argument can be used. This might occur if the</span>
<span class="sd">    resource is being dynamically created on the client (e.g. application</span>
<span class="sd">    logs). To use this argument:</span>

<span class="sd">    .. testsetup:: resumable-unknown-size</span>

<span class="sd">       import io</span>

<span class="sd">       import mock</span>
<span class="sd">       import requests</span>
<span class="sd">       from six.moves import http_client</span>

<span class="sd">       from google.resumable_media.requests import ResumableUpload</span>

<span class="sd">       upload_url = u&#39;http://test.invalid&#39;</span>
<span class="sd">       chunk_size = 3 * 1024 * 1024  # 3MB</span>
<span class="sd">       upload = ResumableUpload(upload_url, chunk_size)</span>

<span class="sd">       fake_response = requests.Response()</span>
<span class="sd">       fake_response.status_code = int(http_client.OK)</span>
<span class="sd">       fake_response._content = b&#39;&#39;</span>
<span class="sd">       resumable_url = u&#39;http://test.invalid?upload_id=7up&#39;</span>
<span class="sd">       fake_response.headers[u&#39;location&#39;] = resumable_url</span>

<span class="sd">       post_method = mock.Mock(return_value=fake_response, spec=[])</span>
<span class="sd">       transport = mock.Mock(request=post_method, spec=[&#39;request&#39;])</span>

<span class="sd">       metadata = {u&#39;name&#39;: u&#39;some-file.jpg&#39;}</span>
<span class="sd">       content_type = u&#39;application/octet-stream&#39;</span>

<span class="sd">       stream = io.BytesIO(b&#39;data&#39;)</span>

<span class="sd">    .. doctest:: resumable-unknown-size</span>

<span class="sd">       &gt;&gt;&gt; response = upload.initiate(</span>
<span class="sd">       ...     transport, stream, metadata, content_type,</span>
<span class="sd">       ...     stream_final=False)</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; upload.total_bytes is None</span>
<span class="sd">       True</span>

<span class="sd">    Args:</span>
<span class="sd">        upload_url (str): The URL where the resumable upload will be initiated.</span>
<span class="sd">        chunk_size (int): The size of each chunk used to upload the resource.</span>
<span class="sd">        headers (Optional[Mapping[str, str]]): Extra headers that should</span>
<span class="sd">            be sent with the :meth:`initiate` request, e.g. headers for</span>
<span class="sd">            encrypted data. These **will not** be sent with</span>
<span class="sd">            :meth:`transmit_next_chunk` or :meth:`recover` requests.</span>
<span class="sd">        checksum Optional([str]): The type of checksum to compute to verify</span>
<span class="sd">            the integrity of the object. After the upload is complete, the</span>
<span class="sd">            server-computed checksum of the resulting object will be checked</span>
<span class="sd">            and google.resumable_media.common.DataCorruption will be raised on</span>
<span class="sd">            a mismatch. The corrupted file will not be deleted from the remote</span>
<span class="sd">            host automatically. Supported values are &quot;md5&quot;, &quot;crc32c&quot; and None.</span>
<span class="sd">            The default is None.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        upload_url (str): The URL where the content will be uploaded.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If ``chunk_size`` is not a multiple of</span>
<span class="sd">            :data:`.UPLOAD_CHUNK_SIZE`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ResumableUpload.initiate"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.ResumableUpload.initiate">[docs]</a>    <span class="k">def</span> <span class="nf">initiate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transport</span><span class="p">,</span>
        <span class="n">stream</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">,</span>
        <span class="n">content_type</span><span class="p">,</span>
        <span class="n">total_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stream_final</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="p">(</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_CONNECT_TIMEOUT</span><span class="p">,</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_READ_TIMEOUT</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initiate a resumable upload.</span>

<span class="sd">        By default, this method assumes your ``stream`` is in a &quot;final&quot;</span>
<span class="sd">        state ready to transmit. However, ``stream_final=False`` can be used</span>
<span class="sd">        to indicate that the size of the resource is not known. This can happen</span>
<span class="sd">        if bytes are being dynamically fed into ``stream``, e.g. if the stream</span>
<span class="sd">        is attached to application logs.</span>

<span class="sd">        If ``stream_final=False`` is used, :attr:`chunk_size` bytes will be</span>
<span class="sd">        read from the stream every time :meth:`transmit_next_chunk` is called.</span>
<span class="sd">        If one of those reads produces strictly fewer bites than the chunk</span>
<span class="sd">        size, the upload will be concluded.</span>

<span class="sd">        Args:</span>
<span class="sd">            transport (~requests.Session): A ``requests`` object which can</span>
<span class="sd">                make authenticated requests.</span>
<span class="sd">            stream (IO[bytes]): The stream (i.e. file-like object) that will</span>
<span class="sd">                be uploaded. The stream **must** be at the beginning (i.e.</span>
<span class="sd">                ``stream.tell() == 0``).</span>
<span class="sd">            metadata (Mapping[str, str]): The resource metadata, such as an</span>
<span class="sd">                ACL list.</span>
<span class="sd">            content_type (str): The content type of the resource, e.g. a JPEG</span>
<span class="sd">                image has content type ``image/jpeg``.</span>
<span class="sd">            total_bytes (Optional[int]): The total number of bytes to be</span>
<span class="sd">                uploaded. If specified, the upload size **will not** be</span>
<span class="sd">                determined from the stream (even if ``stream_final=True``).</span>
<span class="sd">            stream_final (Optional[bool]): Indicates if the ``stream`` is</span>
<span class="sd">                &quot;final&quot; (i.e. no more bytes will be added to it). In this case</span>
<span class="sd">                we determine the upload size from the size of the stream. If</span>
<span class="sd">                ``total_bytes`` is passed, this argument will be ignored.</span>
<span class="sd">            timeout (Optional[Union[float, Tuple[float, float]]]):</span>
<span class="sd">                The number of seconds to wait for the server response.</span>
<span class="sd">                Depending on the retry strategy, a request may be repeated</span>
<span class="sd">                several times using the same timeout each time.</span>

<span class="sd">                Can also be passed as a tuple (connect_timeout, read_timeout).</span>
<span class="sd">                See :meth:`requests.Session.request` documentation for details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ~requests.Response: The HTTP response returned by ``transport``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_initiate_request</span><span class="p">(</span>
            <span class="n">stream</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">content_type</span><span class="p">,</span>
            <span class="n">total_bytes</span><span class="o">=</span><span class="n">total_bytes</span><span class="p">,</span>
            <span class="n">stream_final</span><span class="o">=</span><span class="n">stream_final</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">_request_helpers</span><span class="o">.</span><span class="n">http_request</span><span class="p">(</span>
            <span class="n">transport</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
            <span class="n">retry_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_strategy</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_initiate_response</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span></div>

<div class="viewcode-block" id="ResumableUpload.transmit_next_chunk"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.ResumableUpload.transmit_next_chunk">[docs]</a>    <span class="k">def</span> <span class="nf">transmit_next_chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transport</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="p">(</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_CONNECT_TIMEOUT</span><span class="p">,</span>
            <span class="n">_request_helpers</span><span class="o">.</span><span class="n">_DEFAULT_READ_TIMEOUT</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transmit the next chunk of the resource to be uploaded.</span>

<span class="sd">        If the current upload was initiated with ``stream_final=False``,</span>
<span class="sd">        this method will dynamically determine if the upload has completed.</span>
<span class="sd">        The upload will be considered complete if the stream produces</span>
<span class="sd">        fewer than :attr:`chunk_size` bytes when a chunk is read from it.</span>

<span class="sd">        In the case of failure, an exception is thrown that preserves the</span>
<span class="sd">        failed response:</span>

<span class="sd">        .. testsetup:: bad-response</span>

<span class="sd">           import io</span>

<span class="sd">           import mock</span>
<span class="sd">           import requests</span>
<span class="sd">           from six.moves import http_client</span>

<span class="sd">           from google import resumable_media</span>
<span class="sd">           import google.resumable_media.requests.upload as upload_mod</span>

<span class="sd">           transport = mock.Mock(spec=[&#39;request&#39;])</span>
<span class="sd">           fake_response = requests.Response()</span>
<span class="sd">           fake_response.status_code = int(http_client.BAD_REQUEST)</span>
<span class="sd">           transport.request.return_value = fake_response</span>

<span class="sd">           upload_url = u&#39;http://test.invalid&#39;</span>
<span class="sd">           upload = upload_mod.ResumableUpload(</span>
<span class="sd">               upload_url, resumable_media.UPLOAD_CHUNK_SIZE)</span>
<span class="sd">           # Fake that the upload has been initiate()-d</span>
<span class="sd">           data = b&#39;data is here&#39;</span>
<span class="sd">           upload._stream = io.BytesIO(data)</span>
<span class="sd">           upload._total_bytes = len(data)</span>
<span class="sd">           upload._resumable_url = u&#39;http://test.invalid?upload_id=nope&#39;</span>

<span class="sd">        .. doctest:: bad-response</span>
<span class="sd">           :options: +NORMALIZE_WHITESPACE</span>

<span class="sd">           &gt;&gt;&gt; error = None</span>
<span class="sd">           &gt;&gt;&gt; try:</span>
<span class="sd">           ...     upload.transmit_next_chunk(transport)</span>
<span class="sd">           ... except resumable_media.InvalidResponse as caught_exc:</span>
<span class="sd">           ...     error = caught_exc</span>
<span class="sd">           ...</span>
<span class="sd">           &gt;&gt;&gt; error</span>
<span class="sd">           InvalidResponse(&#39;Request failed with status code&#39;, 400,</span>
<span class="sd">                           &#39;Expected one of&#39;, &lt;HTTPStatus.OK: 200&gt;, 308)</span>
<span class="sd">           &gt;&gt;&gt; error.response</span>
<span class="sd">           &lt;Response [400]&gt;</span>

<span class="sd">        Args:</span>
<span class="sd">            transport (~requests.Session): A ``requests`` object which can</span>
<span class="sd">                make authenticated requests.</span>
<span class="sd">            timeout (Optional[Union[float, Tuple[float, float]]]):</span>
<span class="sd">                The number of seconds to wait for the server response.</span>
<span class="sd">                Depending on the retry strategy, a request may be repeated</span>
<span class="sd">                several times using the same timeout each time.</span>

<span class="sd">                Can also be passed as a tuple (connect_timeout, read_timeout).</span>
<span class="sd">                See :meth:`requests.Session.request` documentation for details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ~requests.Response: The HTTP response returned by ``transport``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ~google.resumable_media.common.InvalidResponse: If the status</span>
<span class="sd">                code is not 200 or 308.</span>
<span class="sd">            ~google.resumable_media.common.DataCorruption: If this is the final</span>
<span class="sd">                chunk, a checksum validation was requested, and the checksum</span>
<span class="sd">                does not match or is not available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_request</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">_request_helpers</span><span class="o">.</span><span class="n">http_request</span><span class="p">(</span>
            <span class="n">transport</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
            <span class="n">retry_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_strategy</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_response</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">response</span></div>

<div class="viewcode-block" id="ResumableUpload.recover"><a class="viewcode-back" href="../../../../resumable_media/requests.html#google.resumable_media.requests.ResumableUpload.recover">[docs]</a>    <span class="k">def</span> <span class="nf">recover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recover from a failure.</span>

<span class="sd">        This method should be used when a :class:`ResumableUpload` is in an</span>
<span class="sd">        :attr:`~ResumableUpload.invalid` state due to a request failure.</span>

<span class="sd">        This will verify the progress with the server and make sure the</span>
<span class="sd">        current upload is in a valid state before :meth:`transmit_next_chunk`</span>
<span class="sd">        can be used again.</span>

<span class="sd">        Args:</span>
<span class="sd">            transport (~requests.Session): A ``requests`` object which can</span>
<span class="sd">                make authenticated requests.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ~requests.Response: The HTTP response returned by ``transport``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_recover_request</span><span class="p">()</span>
        <span class="c1"># NOTE: We assume &quot;payload is None&quot; but pass it along anyway.</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">_request_helpers</span><span class="o">.</span><span class="n">http_request</span><span class="p">(</span>
            <span class="n">transport</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
            <span class="n">retry_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_strategy</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_recover_response</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">google-resumable-media</a></h1>



<p class="blurb">Google Cloud Client Libraries for google-resumable-media</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=googleapis&repo=google-resumable-media-python&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../resumable_media/common.html">Common Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resumable_media/requests.html">Requests Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Google.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/googleapis/google-resumable-media-python" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>